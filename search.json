[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Einführung in die mathematische Optimierung",
    "section": "",
    "text": "Setup\nIn den Übungen werden wir die Programmiersprache Python verwenden, um die in der Vorlesung behandelten Themen zu erklären und an realen Daten zu üben. Die Übungen werden in Form von Jupyter Notebooks bereitgestellt, die Sie in Ihrer eigenen Umgebung ausführen können.\nDeswegen ist es notwendig, zuerst eine Arbeitsumgebung einzurichten.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#git",
    "href": "index.html#git",
    "title": "Einführung in die mathematische Optimierung",
    "section": "Git",
    "text": "Git\nDie Übungen werden in einem Git-Repository auf GitHub bereitgestellt. Git ist ein Versionskontrollsystem, das die Änderungen an Dateien verfolgt und es ermöglicht, verschiedene Versionen von Dateien zu speichern. GitHub ist eine Plattform, die auf Git basiert und es ermöglicht, Git-Repositories zu hosten und zu teilen.\nWir werden Git verwenden, um die Übungen herunterzuladen und um Ihre Lösungen hochzuladen.\nInstallieren Sie Git von https://git-scm.com/downloads. Wählen Sie die Version, die zu Ihrem Betriebssystem passt und folgen Sie den Anweisungen. Lassen Sie die Standardeinstellungen unverändert, es sei denn, Sie wissen ganz genau, was Sie tun.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#github-account",
    "href": "index.html#github-account",
    "title": "Einführung in die mathematische Optimierung",
    "section": "GitHub Account",
    "text": "GitHub Account\nFür die Übungen brauchen Sie ein GitHub.com Konto:\n\nErstellen Sie ein Konto auf https://github.com/signup.\nBei der Registrierung wählen Sie ein Passwort, das Sie nirgendwo anders verwenden. Am Ende des Semesters können Sie Ihr Passwort ändern.\nEmpfehlung: Aktivieren Sie die Zwei-Faktor-Authentifizierung (2FA) in den Einstellungen Ihres GitHub-Kontos.\nEmpfehlung: Beantragen Sie die Studentenvorteile, um kostenlosen Zugang zu GitHub Copilot zu erhalten, einem KI-gestützten Code-Completion- und Chat-Tool.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#visual-studio-code",
    "href": "index.html#visual-studio-code",
    "title": "Einführung in die mathematische Optimierung",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\nVisual Studio Code (VSC) ist ein Open-Source-Code-Editor, den wir für die Arbeit mit Python benutzen werden.\nInstallieren Sie Visual Studio Code von https://code.visualstudio.com/. Wählen Sie die Version, die zu Ihrem Betriebssystem passt und folgen Sie den Anweisungen.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#kursrepository-klonen",
    "href": "index.html#kursrepository-klonen",
    "title": "Einführung in die mathematische Optimierung",
    "section": "Kursrepository klonen",
    "text": "Kursrepository klonen\nÖffnen Sie VSC und drücken Sie Ctrl+Shift+P. Suchen Sie nach “Git: Clone” und drücken Sie Enter. Geben Sie die URL des Kursrepositories ein:\nhttp://github.com/febse/opt2024-de.git\nWählen Sie einen Ordner auf Ihrem Computer, in dem Sie das Repository speichern möchten. VSC wird das Repository herunterladen und fragen, ob Sie es öffnen möchten. Klicken Sie auf “Open”.\nWarten Sie einen Moment, bis VSC das Repository geöffnet hat. Sie sollten eine Ordnerstruktur sehen, die den Inhalt des Repositories darstellt. VSC wird Sie fragen, ob Sie die empfohlenen Erweiterungen installieren möchten. Klicken Sie auf “Install All”.\nAm Ende sollten Sie die folgenden Erweiterungen installiert haben:\n\nms-python.autopep8\nms-python.python\nms-python.debugpy\nms-vscode-remote.remote-containers\nms-toolsai.jupyter\ngithub.codespaces\ngithub.copilot\n\nDrucken Sie Ctrl+Shift+X. Dieses wird die Erweiterungsansicht öffnen. Überprüfen Sie ob alle Erweiterungen installiert sind. Falls nicht, kopieren Sie die Kennzeichen (z.B. ms-python.autopep8) der fehlenden Erweiterungen von der Liste (oben), finden Sie die Erweiterungen in der Erweiterungsansicht und installieren Sie sie manuell.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#python",
    "href": "index.html#python",
    "title": "Einführung in die mathematische Optimierung",
    "section": "Python",
    "text": "Python\nPython ist zurzeit eine der meistbenutzten Programmiersprachen in der Welt. Es ist einfach zu lernen und hat eine große Community, die viele Bibliotheken und Frameworks entwickelt hat. In der Welt der Datenwissenschaft werden meistens Python und R benutzt. In den letzten Jahren stieg die Popularität von Python.\n\nCodespaces (empfohlen)\nUm die Konfiguration zu vereinfachen, können Sie Codespaces benutzen. In den ersten Übungen werden wir eine Anleitung zeigen, wie Sie Codespaces benutzen können.\n\n\nMiniconda\nEs gibt viele Möglichkeiten, wie Sie Python local auf Ihrem Rechner installieren können. Hier zeigen wir die Installation mit Miniconda. Conda ist ein Paketmanager, der es ermöglicht, Python-Umgebungen zu verwalten. Eine Python-Umgebung ist eine isolierte Instanz von Python, die es ermöglicht, verschiedene Versionen von Python und verschiedenen Bibliotheken zu verwenden, ohne dass sie sich gegenseitig beeinflussen. Das ist vor allem dann nützlich, wenn Sie an verschiedenen Projekten arbeiten, die unterschiedliche Anforderungen an Python und Bibliotheken haben.\n\nLaden Sie das Miniconda Installationspaket von https://docs.conda.io/en/latest/miniconda.html für Ihr Betriebssystem.\nStarten Sie das Packet und folgen Sie den Anweisungen. Lassen Sie die Standardeinstellungen unverändert, es sei denn, Sie wissen was Sie tun.\nInstallieren Sie Conda in einem Ordner ohne Leerzeichen und nur mit ASCII Zeichen im Pfad (d.h. keine Kyrillischen Zeichen, keine Umlaute, etc.), z.B. C:\\Miniconda3 oder C:\\Users\\boyko\\Miniconda3.\nNachdem Miniconda installiert ist, öffnen Sie VSC. Drücken Sie Ctrl+Shift+P und starten Sie zu schreiben: “Python: Create environment”. Wenn die Option in dem Dropdown-Menü erscheint, wählen Sie sie und drucken Sie Enter.\nWählen Sie “Conda”.\nWählen Sie die Python-3.11 Version.\nDieses wird einen Order namens .conda erstellen.\nFalls Sie diese Schritte in dem Order des Kursrepositories gemacht haben, werden dann automatisch die notwendingen Bibliotheken installiert.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "index.html#pycharm-optional",
    "href": "index.html#pycharm-optional",
    "title": "Einführung in die mathematische Optimierung",
    "section": "PyCharm (optional)",
    "text": "PyCharm (optional)\nStatt VSC können Sie auch PyCharm oder DataSpell benutzen. PyCharm ist eine integrierte Entwicklungsumgebung (IDE) für Python, die von JetBrains entwickelt wurde. PyCharm ist eine der beliebtesten Python-IDEs und bietet viele Funktionen, die die Entwicklung von Python-Programmen erleichtern. Falls Sie mit PyCharm oder DataSpell experimentieren möchten, bieten wir für die Übungen kostenfreie Lizenzen an.\n\nRegistrieren Sie sich auf https://account.jetbrains.com/signup mit Ihrer Universitäts-E-Mail-Adresse (muss auf feb.uni-sofia.bg oder feba.uni-sofia.bg enden).\nLaden Sie Pycharm von https://www.jetbrains.com/pycharm/download/ herunter und installieren Sie es.\nBeim Aktivierungsdialog wählen Sie “Licence Server” und geben Sie https://febs.fls.jetbrains.com/ ein.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "01-Python/01-01-Basics.html",
    "href": "01-Python/01-01-Basics.html",
    "title": "1  Python Basics",
    "section": "",
    "text": "1.1 Jupyter Notebooks in VS Code\nHäufig verwendete Tastenkombinationen\nShortcuts für den Kommando-Modus (Edit Mode)\nShortcuts für den Edit Modus - Alt + Shift + ↑: Die aktuelle Zeile nach oben kopieren (Fokus bleibt auf der aktuellen Zeile) - Alt + Shift + ↓: Die aktuelle Zeile nach unten kopieren (Fokus verlagert sich zur nächsten Zeile) - Ctrl+Enter/Shift+Enter: Markierte Zelle ausführen und Fokus auf die nächste Zelle setzen\nShortcuts für beide Modi",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "01-Python/01-01-Basics.html#jupyter-notebooks-in-vs-code",
    "href": "01-Python/01-01-Basics.html#jupyter-notebooks-in-vs-code",
    "title": "1  Python Basics",
    "section": "",
    "text": "Enter: Bearbeitungsmodus einschalten\nEsc: Kommando-Modus einschalten\n\n\n\nA : Eine Zelle oberhalb der aktuellen Zelle einfügen\nB : Eine Zelle unterhalb der aktuellen Zelle einfügen\nAlt + ↑: Zelle nach oben verschieben\nAlt + ↓: Zelle nach unten verschieben\nAlt + Shift + ↑: Zelle nach oben kopieren (Fokus bleibt auf der aktuellen Zelle)\nAlt + Shift + ↓: Zelle nach unten kopieren (der Fokus wechselt zur nächsten Zelle)\ndd : Zelle löschen\nz : Die letzte Änderung rückgängig machen\nM : Die Zelle in eine Markdown-Zelle umwandeln\nY: Die Zelle in eine Code-Zelle umwandeln\n\n\n\n\nCtrl+Enter : Die aktuelle Zelle ausführen (Fokus bleibt auf der aktuellen Zelle)\nShift+Enter : Die aktuelle Zelle ausführen und Fokus auf die nächste Zelle setzen\nAlt+Enter : Die aktuelle Zelle ausführen und eine neue Zelle einfügen",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "01-Python/01-01-Basics.html#arithmetische-operationen",
    "href": "01-Python/01-01-Basics.html#arithmetische-operationen",
    "title": "1  Python Basics",
    "section": "1.2 Arithmetische Operationen",
    "text": "1.2 Arithmetische Operationen\n\n# Addition\n1 + 1\n\n2\n\n\nDie Varianz von Y ist größer als die Varianz von X. Das bedeutet, daß die Werte, die Y produziert, weiter von ihrem Erwartungswert entfernt sein werden als die Werte, die X produziert.\n\n# Division\n1 / 2\n\n0.5\n\n\n\n# Multiplikation\n2 * 3\n\n6\n\n\n\n# Potenz\n2.3 ** 8\n\n783.1098528099996\n\n\n\n# Typ\ntype(1)\n\nint\n\n\n\ntype(1.0)\n\nfloat\n\n\n\n1.2.1 Zuweisung (Assignment)\nWir können Werte Variablen zuweisen. In Python verwenden wir dazu das Gleichheitszeichen =. Der Wert auf der rechten Seite des Gleichheitszeichens wird der Variablen auf der linken Seite zugewiesen. Anders als in der Mathematik, wo die Gleichung x = 3 bedeutet, dass x gleich 3 ist, bedeutet die Zuweisung x = 3 in Python, dass der Wert 3 in der Variablen x gespeichert wird. Python speichert dann den Wert 3 im Speicher des Rechners und weist ihm den Namen x zu.\n\nx = 1\ny = 5\n\n\nx + y\n\n6\n\n\n\ntype(x)\n\nint\n\n\n\n\n1.2.2 Zeichenketten (Strings)\nAußer Zahlen können wir auch Zeichenketten (Strings) speichern.\n\nz = \"Hallo, Welt!\"\nz\n\n'Hallo, Welt!'\n\n\n\nprint(z)\n\nHallo, Welt!\n\n\nZeichenketten können wir mit + verketten.\n\nz1 = z + \" Ich bin da!\"\nprint(z1)\n\nHallo, Welt! Ich bin da!\n\n\nZeichenketten können wir mit * “vervielfachen”.\n\nprint(z * 3)\n\nHallo, Welt!Hallo, Welt!Hallo, Welt!\n\n\nZeichenketten können wir mit len die Länge (Anzahl der Zeichen) bestimmen.\n\nlen(z)\n\n12\n\n\nZeichenketten können wir mit split in eine Liste von Wörtern aufteilen.\n\nz.split(\",\")\n\n['Hallo', ' Welt!']\n\n\n\nz.split(\" \")\n\n['Hallo,', 'Welt!']\n\n\nWir können Teile einer Zeichenkette mit eckigen Klammern auswählen. Dabei beginnt der Index bei 0.\n\nz[0]\n\n'H'\n\n\n\nz[1]\n\n'a'\n\n\n\nz[0:5]\n\n'Hallo'\n\n\n\nfor char in z:\n    print(char)\n\nH\na\nl\nl\no\n,\n \nW\ne\nl\nt\n!\n\n\n\n\n1.2.3 Logische Werte (Booleans)\nIn Python gibt es auch logische Werte (Booleans). Diese können nur zwei Werte annehmen: True und False. In den meisten Fällen werden wir diese Werte verwenden, um Bedingungen zu formulieren.\n\n1 &gt; 2\n\nFalse\n\n\n\n1 &lt; 3\n\nTrue\n\n\n\n2 == 2\n\nTrue\n\n\n\n\"hallo\" == \"hallo\"\n\nTrue\n\n\n\n\"hallo\" == \"Hallo\"\n\nFalse",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "01-Python/01-01-Basics.html#listen-und-tupel",
    "href": "01-Python/01-01-Basics.html#listen-und-tupel",
    "title": "1  Python Basics",
    "section": "1.3 Listen und Tupel",
    "text": "1.3 Listen und Tupel\nIn vielen Fällen werden wir nicht nur einzelne Werte, sondern mehrere Werte zusammen verwenden wollen. Als Beispiel nehmen wir eine Liste mit monatlichem Stromverbrauch eines Unternehmens (für 12 Monate in EUR).\n\nstromverbrauch = [100, 120, 80, 90, 110, 100, 120, 80, 90.12, 110, 100, 120.22]\n\nWir können auf einzelne Elemente einer Liste zugreifen, indem wir den Index des Elements in eckigen Klammern hinter den Namen der Liste schreiben. Wie in den meisten Programmiersprachen beginnt der Index bei 0.\n\nstromverbrauch[0]\n\n100\n\n\n\nstromverbrauch[1]\n\n120\n\n\n\nstromverbrauch[11]\n\n120.22\n\n\nVersuchen wir auf ein Element zuzugreifen, das nicht existiert, erhalten wir einen Fehler.\n\n# stromverbrauch[12]\n\nDie Länge einer Liste können wir mit der Funktion len bestimmen. Diese gibt uns die Anzahl der Elemente in der Liste zurück.\n\nlen(stromverbrauch)\n\n12\n\n\nWir können auch auf die letzten Elemente einer Liste zugreifen, indem wir negative Indizes verwenden.\n\nstromverbrauch[len(stromverbrauch) - 1]\n\n120.22\n\n\n\nstromverbrauch[-1]\n\n120.22\n\n\nWir können auch auf mehrere Elemente einer Liste zugreifen, indem wir den Index des ersten Elements und den Index des letzten Elements in eckigen Klammern hinter den Namen der Liste schreiben. Der Index des letzten Elements ist dabei exklusiv.\n\nstromverbrauch[0:3]\n\n[100, 120, 80]\n\n\nDas ist das gleiche wie\n\nstromverbrauch[:3]\n\n[100, 120, 80]\n\n\n\nstromverbrauch[0:3] == stromverbrauch[:3]\n\nTrue\n\n\n\nstromverbrauch[3:6]\n\n[90, 110, 100]\n\n\nWir können einzelne Elemente einer Liste verändern.\n\nstromverbrauch[0] = 1\nstromverbrauch\n\n[1, 120, 80, 90, 110, 100, 120, 80, 90.12, 110, 100, 120.22]\n\n\nWir können auch mehrere Elemente einer Liste verändern.\n\nstromverbrauch[0:3] = [5, 5, 8]\nstromverbrauch\n\n[5, 5, 8, 90, 110, 100, 120, 80, 90.12, 110, 100, 120.22]\n\n\nTuple sind wie Listen, nur dass sie nicht verändert werden können. Wir können sie mit runden Klammern erstellen. Im folgenden Beispiel erstellen wir ein Tuple mit den Monatsnamen. Dann versuchen wir, das erste Element zu verändern. Das funktioniert nicht.\n\nmonatsnamen = (\"Januar\", \"Februar\", \"März\", \"April\", \"Mai\", \"Juni\", \"Juli\",\n               \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\")\n\n\n# monatsnamen[0] = \"Jänner\"\n\n\n1.3.1 Schleifen\nIn vielen Fällen wollen wir eine Operation auf alle Elemente einer Liste anwenden. Dafür können wir Schleifen verwenden.\n\nfor g in stromverbrauch:\n    print(f\"Der Stromverbrauch war {g} EUR\")\n\nDer Stromverbrauch war 5 EUR\nDer Stromverbrauch war 5 EUR\nDer Stromverbrauch war 8 EUR\nDer Stromverbrauch war 90 EUR\nDer Stromverbrauch war 110 EUR\nDer Stromverbrauch war 100 EUR\nDer Stromverbrauch war 120 EUR\nDer Stromverbrauch war 80 EUR\nDer Stromverbrauch war 90.12 EUR\nDer Stromverbrauch war 110 EUR\nDer Stromverbrauch war 100 EUR\nDer Stromverbrauch war 120.22 EUR\n\n\n\nfor idx, g in enumerate(stromverbrauch):\n    print(f\"Der Stromverbrauch im Monat {monatsnamen[idx]} war {g} EUR.\")\n\nDer Stromverbrauch im Monat Januar war 5 EUR.\nDer Stromverbrauch im Monat Februar war 5 EUR.\nDer Stromverbrauch im Monat März war 8 EUR.\nDer Stromverbrauch im Monat April war 90 EUR.\nDer Stromverbrauch im Monat Mai war 110 EUR.\nDer Stromverbrauch im Monat Juni war 100 EUR.\nDer Stromverbrauch im Monat Juli war 120 EUR.\nDer Stromverbrauch im Monat August war 80 EUR.\nDer Stromverbrauch im Monat September war 90.12 EUR.\nDer Stromverbrauch im Monat Oktober war 110 EUR.\nDer Stromverbrauch im Monat November war 100 EUR.\nDer Stromverbrauch im Monat Dezember war 120.22 EUR.\n\n\nDie Namen der Variablen in der for-Schleife können wir frei wählen (diese müssen allerdings valide Variablennamen sein).\n\nfor i, verbrauch in enumerate(stromverbrauch):\n    print(f\"Der Stromverbrauch im Monat {monatsnamen[i]} war {verbrauch} EUR.\")\n\nDer Stromverbrauch im Monat Januar war 5 EUR.\nDer Stromverbrauch im Monat Februar war 5 EUR.\nDer Stromverbrauch im Monat März war 8 EUR.\nDer Stromverbrauch im Monat April war 90 EUR.\nDer Stromverbrauch im Monat Mai war 110 EUR.\nDer Stromverbrauch im Monat Juni war 100 EUR.\nDer Stromverbrauch im Monat Juli war 120 EUR.\nDer Stromverbrauch im Monat August war 80 EUR.\nDer Stromverbrauch im Monat September war 90.12 EUR.\nDer Stromverbrauch im Monat Oktober war 110 EUR.\nDer Stromverbrauch im Monat November war 100 EUR.\nDer Stromverbrauch im Monat Dezember war 120.22 EUR.",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "01-Python/01-01-Basics.html#dictionaries",
    "href": "01-Python/01-01-Basics.html#dictionaries",
    "title": "1  Python Basics",
    "section": "3.1 Dictionaries",
    "text": "3.1 Dictionaries\nEs is sehr häufig, dass wir nicht nur einzelne Werte, sondern ganze Datensätze verwenden wollen. Dafür können wir Dictionaries verwenden. Dictionaries sind wie Listen, nur dass wir nicht mit Indizes, sondern mit Schlüsseln auf die Elemente zugreifen. Schlüssel können beliebige unveränderbare Datentypen sein (z.B. Strings, Zahlen, Tupel). Werte können beliebige Datentypen sein. Wir können Dictionaries mit geschweiften Klammern erstellen. Die Werte in einem Dictionary werden mit einem Doppelpunkt vom Schlüssel getrennt. Die einzelnen Elemente werden mit Kommas getrennt.\nDie Ordnung der Elemente ist nicht definiert.\n\nstromverbrauch_dict = {\n    \"Januar\": 100,\n    \"Februar\": 120,\n    \"März\": 80,\n    \"April\": 90,\n    \"Mai\": 110,\n    \"Juni\": 100,\n    \"Juli\": 120,\n    \"August\": 80,\n    \"September\": 90.12,\n    \"Oktober\": 110,\n    \"November\": 100,\n    \"Dezember\": 120.22\n}\n\n\nstromverbrauch_dict[\"Januar\"]\n\n100\n\n\n\n# stromverbrauch_dict[\"FDFFF\"]\n\nWir können auf\n\nstromverbrauch_dict.get(\"Januar\")\n\n100\n\n\n\n# stromverbrauch_dict.get(\"FDFF\") == None\n\nWir können über die Schlüssel eines Dictionaries iterieren.\n\nfor key in stromverbrauch_dict:\n    print(key)\n\nJanuar\nFebruar\nMärz\nApril\nMai\nJuni\nJuli\nAugust\nSeptember\nOktober\nNovember\nDezember\n\n\nWir können auch über die Schlüssel und Werte eines Dictionaries iterieren.\n\nfor key, value in stromverbrauch_dict.items():\n    print(f\"Im {key} war der Stromverbrauch {value} EUR.\")\n\nIm Januar war der Stromverbrauch 100 EUR.\nIm Februar war der Stromverbrauch 120 EUR.\nIm März war der Stromverbrauch 80 EUR.\nIm April war der Stromverbrauch 90 EUR.\nIm Mai war der Stromverbrauch 110 EUR.\nIm Juni war der Stromverbrauch 100 EUR.\nIm Juli war der Stromverbrauch 120 EUR.\nIm August war der Stromverbrauch 80 EUR.\nIm September war der Stromverbrauch 90.12 EUR.\nIm Oktober war der Stromverbrauch 110 EUR.\nIm November war der Stromverbrauch 100 EUR.\nIm Dezember war der Stromverbrauch 120.22 EUR.",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "01-Python/01-01-Basics.html#klassen-und-objekte",
    "href": "01-Python/01-01-Basics.html#klassen-und-objekte",
    "title": "1  Python Basics",
    "section": "4.1 Klassen und Objekte",
    "text": "4.1 Klassen und Objekte\nBisher haben wir verschiedene Datentypen gesehen, drei verschiedene Datenstrukturen (Listen, Tupel und Dictionaries) und Funktionen gesehen. In Python gibt es auch Objekte, die Daten und Funktionen zusammenbinden. Funktionen, die zu einem Objekt gehören, nennen wir Methoden. Objekte werden aus Klassen erstellt. Klassen sind wie Baupläne für Objekte. In den Übungen werden wir keine Klassen selber definieren, allerdings werden wir Objekte wie DataFrame, Series, etc. verwenden, die aus Klassen erstellt wurden. Deswegen ist es wichtig, dass Sie wissen, wie Sie mit Objekten umgehen können.\nZuerst definieren wir eine Klasse Person. Diese hat zwei Attribute: name und age. Die Klasse erlaubt uns, ein Objekt zu erstellen, das diese beiden Attribute hat. Wir können auch eine Methode say_hello definieren, die uns erlaubt, “Hallo” und den Namen der Person auszugeben. Alle Methoden, wie z.B. say_hello erhalten das Argument self, das das Objekt selbst ist. Dadurch können wir über Methoden auf die Eigenschaften des Objekts zugreifen.\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def say_hello(self):\n        print(\"Hi, my name is\", self.name, \"and I am\", self.age, \"years old.\")\n\n\nivan = Person(\"Ivan\", 20)\nbetty = Person(\"Betty\", 25)\n\nprint(ivan.name)\nprint(ivan.age)\n\nIvan\n20\n\n\n\nivan.say_hello()\n\nHi, my name is Ivan and I am 20 years old.\n\n\n\nbetty.say_hello()\n\nHi, my name is Betty and I am 25 years old.\n\n\n\n4.1.1 Lambdafunktionen\nManchmal möchten wir eine Funktion nur einmal verwenden. Dafür können wir Lambda Funktionen verwenden. Diese Funktionen haben keinen Namen. Wir können sie mit dem Schlüsselwort lambda erstellen. Die Argumente der Funktion werden durch ein Komma getrennt hinter dem Schlüsselwort lambda geschrieben. Der Rückgabewert der Funktion wird nach einem Doppelpunkt geschrieben.\nZum Beispiel können wir eine Lambdafunktion verwenden, um den Stromverbrauch in BGN zu berechnen.\n\nstromverbrauch_bgn = map(lambda x: x * 1.955, stromverbrauch)",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Python Basics</span>"
    ]
  },
  {
    "objectID": "01-Python/01-02-Basics-Ex.html",
    "href": "01-Python/01-02-Basics-Ex.html",
    "title": "2  Übung: Python Basics",
    "section": "",
    "text": "2.0.1 Aufgabe 1\n\nBerechnen Sie die Summe der Zahlen 32.8 und 45.1\nBerechnen Sie die Differenz der Zahlen 32.8 und 45.1\nSpeichern Sie die Zahl 32.8 in a und die Zahl 45.1 in b. Berechnen Sie das Verhältnis von a zu b und speichern Sie das Ergebnis in c.\n\n\n\n2.0.2 Aufgabe 2\nErstellen Sie eine Liste mit den Zahlen 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 und speichern Sie diese in der Variable numbers. - Geben Sie die Liste aus (mit print()) - Geben Sie das erste Element der Liste aus - Geben Sie das letzte Element der Liste aus - Geben Sie das dritte Element der Liste aus - Geben Sie das dritte und das siebte Element der Liste aus - Ersetzen Sie das vierte Element der Liste durch die Zahl 42\n\n\n2.0.3 Aufgabe 3\nErstellen Sie zwei Listen names und ages mit den folgenden Elementen: - names: “Alice”, “Bob”, “Charlie”, “Dave”, “Eve” - ages: 17, 42, 30, 37, 21\n\nGeben Sie die Liste names aus\nSchreiben Sie eine for-Schleife, die die Namen und das Alter der Personen ausdruckt. Die Ausgabe soll folgendermaßen aussehen: “Alice ist 23 Jahre alt”\nSie möchten nur die Namen der Personen ausdrucken, die älter als 30 Jahre sind. Schreiben Sie eine for-Schleife, die das tut.\nSie möchten eine neue Liste erstellen, die nur die Namen der Personen enthält, die älter als 30 Jahre sind. Schreiben Sie eine Listenabstraktion, die das tut.\n\n\n\n2.0.4 Aufgabe 4\nIn dieser Aufgabe werden wir eine Funktion is_in_list schreiben, die einen Namen als Argument annimmt und True oder False zurückgibt, falls der Name einer Person entspricht, die in der Liste names aus Aufgabe 3 enthalten ist.\n\n\n2.0.5 Aufgabe 5\nIn dieser Aufgabe werden wir eine Funktion get_age schreiben, die einen Namen als Argument annimmt und das Alter der Person zurückgibt, falls der Name einer Person entspricht, die in der Liste names aus Aufgabe 3 enthalten ist. Falls der Name nicht in der Liste enthalten ist, soll die Funktion None zurückgeben.\n\n\n2.0.6 Aufgabe 6\nIn dieser Aufgabe werden wir eine Funktion is_eligible schreiben, die True, False oder None zurückgibt, je nachdem ob eine Person wahlberechtigt ist oder nicht. Die Funktion soll einen Namen als Argument annehmen und das Alter der Person zurückgeben, falls der Name einer Person entspricht, die in der Liste names aus Aufgabe 3 enthalten ist. Falls der Name nicht in der Liste enthalten ist, soll die Funktion None zurückgeben. Falls der Name in der Liste enthalten ist, soll die Funktion True zurückgeben, falls die Person älter als 18 Jahre ist, andernfalls soll die Funktion False zurückgeben.\n\n\n2.0.7 Aufgabe 7\nIn dieser Aufgabe werden wir ein Dictionary erstellen, das die Namen aus Aufgabe 3 als Schlüssel und die Alter aus Aufgabe 3 als Werte enthält. Speichern Sie das Dictionary in der Variable persons.\n\nBenutzen Sie das Dictionary, um das Alter von Bob auszudrucken.\nÄndern Sie das Alter von Alice auf 43 Jahre.\nFügen Sie eine neue Person “Frank” mit dem Alter 33 Jahre hinzu.\nSchreiben Sie eine for-Schleife, die die Namen und das Alter der Personen ausdruckt. Die Ausgabe soll folgendermaßen aussehen: “Alice ist 23 Jahre alt”\nSie möchten nur die Namen der Personen ausdrucken, die mit “A” anfangen. Schreiben Sie eine for-Schleife, die über persons iteriert und das tut.",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Übung: Python Basics</span>"
    ]
  },
  {
    "objectID": "01-Python/01-03-Numpy.html",
    "href": "01-Python/01-03-Numpy.html",
    "title": "3  NumPy",
    "section": "",
    "text": "In der vorherigen Lektion haben wir uns mit Listen beschäftigt. Diese sind sehr flexibel, aber auch sehr langsam. Mit kleinen Listen werden wir das nicht merken, aber wenn wir mit großen Datenmengen arbeiten, dann können lange Laufzeiten zum Problem werden.\nNumPy (Numerical Python) ist ein Paket, das viele Funktionen enthält, die für die Arbeit mit großen Datenmengen geeignet sind.\n\nimport numpy as np\nfrom time import process_time\n\n\n# Wir können eine Liste in ein NumPy-Array umwandeln\npython_list = range(int(1e6))\nnumpy_array = np.array(python_list)\n\n\nstart_zeit = process_time()\n\na_list_plus_2 = [i + 2 for i in python_list]\n\nend_zeit = process_time()\nround(end_zeit - start_zeit, 5)\n\n0.03886\n\n\n\nstart_zeit_1 = process_time()\n\na_array_plus_2 = numpy_array + 2\n\nend_zeit_1 = process_time()\nround(end_zeit_1 - start_zeit_1, 5)\n\n0.0015\n\n\n\nx = np.array([2, 7, 5, 2])\ny = np.ones(4)\ny\n\narray([1., 1., 1., 1.])\n\n\nNumPy-Arrays sind sehr ähnlich zu Listen, aber sie haben einige zusätzliche Eigenschaften. Zum Beispiel können wir mit NumPy-Arrays rechnen. Wenn wir zwei NumPy-Arrays addieren, dann werden die Elemente an der gleichen Stelle addiert. Diese Syntax ist sehr intuitiv und einfach zu lesen.\n\nz1 = x + 1 \nz2 = x + y\nz1\n\narray([3, 8, 6, 3])\n\n\n\nz2\n\narray([3., 8., 6., 3.])\n\n\nDasselbe funktioniert mit Python-Listen nicht. Wenn wir zwei Listen addieren, dann werden die Elemente an der gleichen Stelle nicht addiert, sondern die Listen werden aneinander gehängt.\n\nx_list = [2, 7, 5, 2]\ny_list = [1, 1, 1, 1]\nx_plus_y_list = x_list + y_list\nx_plus_y_list\n\n[2, 7, 5, 2, 1, 1, 1, 1]\n\n\n\n# x_list + 1\n\nNumPy-Arrays haben auch einige Methoden, die wir mit Listen nicht haben. Zum Beispiel können wir die Summe aller Elemente eines Arrays berechnen.\n\n# Summe der Elemente\nx.sum()\n\n16\n\n\n\n# Durchschnitt der Elemente (Arithmetischer Mittelwert)\n\nx.mean()\n\n4.0\n\n\n\n# Standardabweichung\nx.std()\n\n2.1213203435596424\n\n\n\n# Minimum\nx.min()\n\n2\n\n\n\n# Maximum\nx.max()\n\n7\n\n\n\n# Der Index des Minimums\nx.argmin()\n\n0\n\n\n\n# Der Index des Maximums\nx.argmax()\n\n1\n\n\n\n3.0.1 Slicing\nWir können auch auf die Elemente eines Arrays zugreifen, indem wir einen Index angeben. Der Index beginnt bei 0.\n\nz = np.array([\"a\", \"b\", \"c\", \"d\", \"e\"])\n\n\n# Das erste Element\nz[0]\n\n'a'\n\n\n\n# Alle Elemente bis zur Indexposition 2 (exklusive)\n# Achten Sie darauf, dass der Index 0-basiert ist und daher das dritte Element ist eine Indexposition 2 hat\nz[:2]\n\narray(['a', 'b'], dtype='&lt;U1')\n\n\n\nz[-3]\n\n'c'\n\n\n\nz[-3:]\n\narray(['c', 'd', 'e'], dtype='&lt;U1')\n\n\n\nz[1:3]\n\narray(['b', 'c'], dtype='&lt;U1')\n\n\n\nz[::2]\n\narray(['a', 'c', 'e'], dtype='&lt;U1')\n\n\n\nz[::-1]\n\narray(['e', 'd', 'c', 'b', 'a'], dtype='&lt;U1')\n\n\n\n\n3.0.2 Arrays und Listen Zuweisung\nEine zugängige Erläuterung, wie Werte im Speicher des Rechners gespeichert werden, finden Sie in hier.\n\nz[1] = \"x\"\nz\n\narray(['a', 'x', 'c', 'd', 'e'], dtype='&lt;U1')\n\n\n\nz1 = z\n\n\nz[0] = \"X\"\n\n\nz1\n\narray(['X', 'x', 'c', 'd', 'e'], dtype='&lt;U1')\n\n\n\nz1 == z\n\narray([ True,  True,  True,  True,  True])\n\n\n\nprint(id(z1))\nprint(id(z))\n\n140230210743792\n140230210743792\n\n\n\nl1 = [1, 2, 3]\nl2 = l1\n\nprint(id(l1))\nprint(id(l2))\n\n140231100819456\n140231100819456\n\n\n\ns1 = \"Some string\"\ns2 = s1\n\nprint(id(s1))\nprint(id(s2))\n\n# s1[0] = \"X\"\n\n140231100738864\n140231100738864",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>NumPy</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html",
    "href": "01-Python/01-04-Pandas.html",
    "title": "4  Pandas",
    "section": "",
    "text": "4.1 Series\nDie einfachste Datenstruktur in Pandas ist die Series. Eine Series ist eine eindimensionale Datenstruktur, die mit einem NumPy-Array vergleichbar ist. Eine Series kann mit der Funktion pd.Series() erstellt werden. Als Argument wird ein Array übergeben. Die Series hat einen Index, der standardmäßig mit 0 beginnt. Der Index kann mit dem Argument index angepasst werden. Der Index kann ein Array von Strings sein, um die Elemente der Series zu benennen.\n# Erstellen einer Series\ns = pd.Series([1, 2, 3, 4, 5])\ns\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int64\n# Erstellen einer Series mit Index\ns1 = pd.Series([1, 2, 3, 4, 5], index=['a', 'b', 'c', 'd', 'e'])\ns1\n\na    1\nb    2\nc    3\nd    4\ne    5\ndtype: int64\nDie Series hat eine Reihe von Methoden, die aufgerufen werden können. Eine Übersicht über die Methoden kann mit help(pd.Series) aufgerufen werden. Die wichtigsten Methoden sind:\n# Zugriff auf den Index\ns1.index\n\nIndex(['a', 'b', 'c', 'd', 'e'], dtype='object')\n# Zugriff auf die Werte\ns1.values\n\narray([1, 2, 3, 4, 5])\n# Zugriff auf ein Element\ns1['a']\n\n1\n# Zugriff auf mehrere Elemente\ns1[['a', 'c', 'e']]\n\na    1\nc    3\ne    5\ndtype: int64\n# Zugriff auf ein Element mit dem Ganzzahl-Index\ns1.iloc[0]\n\n1\n# Zugriff auf mehrere Elemente mit dem Index\ns1.loc[\"a\"]\n\n1\ns1.loc[[\"a\", \"c\", \"e\"]]\n\na    1\nc    3\ne    5\ndtype: int64\ns1.sum()\n\n15\ns1.mean()\n\n3.0\ns1.std()\n\n1.5811388300841898",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#dataframe",
    "href": "01-Python/01-04-Pandas.html#dataframe",
    "title": "4  Pandas",
    "section": "4.2 DataFrame",
    "text": "4.2 DataFrame\nDas wichtigste Datenobjekt in Pandas ist der DataFrame. Ein DataFrame ist eine zweidimensionale Datenstruktur, die mit einer Tabelle vergleichbar ist. Ein DataFrame kann mit der Funktion pd.DataFrame() erstellt werden. Als Argument wird ein Array übergeben. Der DataFrame hat einen Index, der standardmäßig mit 0 beginnt. Der Index kann mit dem Argument index angepasst werden. Der Index kann ein Array von Strings sein, um die Zeilen des DataFrame zu benennen. Die Spalten des DataFrame können mit dem Argument columns benannt werden.\n\ndf = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 7, 9], [10, 11, 12]], columns=['A', 'B', 'C'])\ndf\n\n\n\n\n\n\n\n\n\nA\nB\nC\n\n\n\n\n0\n1\n2\n3\n\n\n1\n4\n5\n6\n\n\n2\n7\n7\n9\n\n\n3\n10\n11\n12\n\n\n\n\n\n\n\n\n\ndf1 = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 7, 9], [10, 11, 12]],\n                   index=['a', 'b', 'c', 'd'],\n                   columns=['X', 'Y', 'Z']\n                   )\ndf1\n\n\n\n\n\n\n\n\n\nX\nY\nZ\n\n\n\n\na\n1\n2\n3\n\n\nb\n4\n5\n6\n\n\nc\n7\n7\n9\n\n\nd\n10\n11\n12\n\n\n\n\n\n\n\n\nDie DataFrame hat eine Reihe von Methoden, die aufgerufen werden können. Eine Übersicht über die Methoden kann mit help(pd.DataFrame) aufgerufen werden. Die wichtigsten Methoden sind:\n\ndf1[\"X\"].sum()\n\n22\n\n\n\ndf1[\"X\"].mean()\n\n5.5\n\n\n\ndf1[\"X\"].std()\n\n3.872983346207417\n\n\n\ndf1[\"X\"].describe()\n\ncount     4.000000\nmean      5.500000\nstd       3.872983\nmin       1.000000\n25%       3.250000\n50%       5.500000\n75%       7.750000\nmax      10.000000\nName: X, dtype: float64",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#axes",
    "href": "01-Python/01-04-Pandas.html#axes",
    "title": "4  Pandas",
    "section": "4.3 Axes",
    "text": "4.3 Axes\nDie axes eines DataFrame sind die Zeilen und Spalten des DataFrame. Die Zeilen können mit df.index und die Spalten mit df.columns abgerufen werden. Die Eigenschaft (property) shape gibt die Anzahl der Zeilen und Spalten des DataFrame zurück.\n\ndf1.shape\n\n(4, 3)\n\n\nViele Methoden können auf die Zeilen und Spalten des DataFrame angewendet werden.\n\ndf1\n\n\n\n\n\n\n\n\n\nX\nY\nZ\n\n\n\n\na\n1\n2\n3\n\n\nb\n4\n5\n6\n\n\nc\n7\n7\n9\n\n\nd\n10\n11\n12\n\n\n\n\n\n\n\n\n\ndf1.mean(axis=0)\n\nX    5.50\nY    6.25\nZ    7.50\ndtype: float64\n\n\n\ndf1.mean(axis=1)\n\na     2.000000\nb     5.000000\nc     7.666667\nd    11.000000\ndtype: float64\n\n\n\ndf1.mean()\n\nX    5.50\nY    6.25\nZ    7.50\ndtype: float64",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#neue-spalte-hinzufügen",
    "href": "01-Python/01-04-Pandas.html#neue-spalte-hinzufügen",
    "title": "4  Pandas",
    "section": "4.4 Neue Spalte hinzufügen",
    "text": "4.4 Neue Spalte hinzufügen\nEine neue Spalte kann zu einem DataFrame hinzugefügt werden, indem ein neues Array als Wert der neuen Spalte zugewiesen wird. Die neue Spalte wird automatisch an das Ende des DataFrame hinzugefügt.\n\ndf1[\"New\"] = [1, 2, 3, 4]\ndf1.head()\n\n\n\n\n\n\n\n\n\nX\nY\nZ\nNew\n\n\n\n\na\n1\n2\n3\n1\n\n\nb\n4\n5\n6\n2\n\n\nc\n7\n7\n9\n3\n\n\nd\n10\n11\n12\n4\n\n\n\n\n\n\n\n\nHäufig wird eine neue Spalte aus bestehenden Spalten berechnet. Dazu können die bestehenden Spalten wie normale Arrays verwendet werden. Die neue Spalte wird automatisch an das Ende des DataFrame hinzugefügt.\n\ndf1[\"X_min_Y\"] = df1[\"X\"] - df1[\"Y\"]\ndf1.head()\n\n\n\n\n\n\n\n\n\nX\nY\nZ\nNew\nX_min_Y\n\n\n\n\na\n1\n2\n3\n1\n-1\n\n\nb\n4\n5\n6\n2\n-1\n\n\nc\n7\n7\n9\n3\n0\n\n\nd\n10\n11\n12\n4\n-1\n\n\n\n\n\n\n\n\n\ndf1[\"X_2\"] = 2 *df1[\"X\"]\ndf1.head()\n\n\n\n\n\n\n\n\n\nX\nY\nZ\nNew\nX_min_Y\nX_2\n\n\n\n\na\n1\n2\n3\n1\n-1\n2\n\n\nb\n4\n5\n6\n2\n-1\n8\n\n\nc\n7\n7\n9\n3\n0\n14\n\n\nd\n10\n11\n12\n4\n-1\n20",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#selektieren-von-zeilen",
    "href": "01-Python/01-04-Pandas.html#selektieren-von-zeilen",
    "title": "4  Pandas",
    "section": "4.5 Selektieren von Zeilen",
    "text": "4.5 Selektieren von Zeilen\nHäufig möchten wir nur eine Teilmenge der Zeilen eines DataFrame selektieren, z.B. die ersten 5 Zeilen oder die Zeilen, die eine bestimmte Bedingung erfüllen (z.B. Männer/Frauen, beschäftigt/arbeitslos, etc.).\n\n# Als Beispiel wählen wir die ersten drei Zeilen\n\ndf1.iloc[0:2]\n\n\n\n\n\n\n\n\n\nX\nY\nZ\nNew\nX_min_Y\nX_2\n\n\n\n\na\n1\n2\n3\n1\n-1\n2\n\n\nb\n4\n5\n6\n2\n-1\n8\n\n\n\n\n\n\n\n\n\n# Als anderes Beispiel wählen wir die Zeilen, für die X größer als 3 ist\n\ndf1[df1[\"X\"] &gt; 3]\n\n\n\n\n\n\n\n\n\nX\nY\nZ\nNew\nX_min_Y\nX_2\n\n\n\n\nb\n4\n5\n6\n2\n-1\n8\n\n\nc\n7\n7\n9\n3\n0\n14\n\n\nd\n10\n11\n12\n4\n-1\n20",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#selektieren-von-spalten",
    "href": "01-Python/01-04-Pandas.html#selektieren-von-spalten",
    "title": "4  Pandas",
    "section": "4.6 Selektieren von Spalten",
    "text": "4.6 Selektieren von Spalten\nHäufig möchten wir nur eine Teilmenge der Spalten eines DataFrame selektieren, z.B. die Spalten, die für eine bestimmte Analyse relevant sind.\n\ndf1[[\"X\", \"Y\"]]\n\n\n\n\n\n\n\n\n\nX\nY\n\n\n\n\na\n1\n2\n\n\nb\n4\n5\n\n\nc\n7\n7\n\n\nd\n10\n11",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-04-Pandas.html#groupby",
    "href": "01-Python/01-04-Pandas.html#groupby",
    "title": "4  Pandas",
    "section": "4.7 GroupBy",
    "text": "4.7 GroupBy\nMit der Funktion groupby() können die Daten in einem DataFrame gruppiert werden. Die Funktion groupby() gibt ein DataFrameGroupBy-Objekt zurück. Mit diesem Objekt können verschiedene Aggregationsfunktionen aufgerufen werden. Die wichtigsten Aggregationsfunktionen sind: - count(): Anzahl der Elemente - sum(): Summe der Elemente - mean(): Mittelwert der Elemente - median(): Median der Elemente - min(): Minimum der Elemente - max(): Maximum der Elemente - std(): Standardabweichung der Elemente - var(): Varianz der Elemente - describe(): Statistische Kennzahlen der Elemente - first(): Erstes Element - last(): Letztes Element - nth(): n-tes Element\n\ndf2 = pd.DataFrame({\n    \"Name\": [\"Alice\", \"Bob\", \"Mallory\", \"Mallory\", \"Bob\", \"Mallory\"],\n    \"Gender\": [\"f\", \"m\", \"f\", \"f\", \"m\", \"f\"],\n    \"YearOfBirth\": [1999, 1985, 1997, 1990, 1987, 1990],\n}\n)\ndf2[\"Age\"] = 2024 - df2[\"YearOfBirth\"]\ndf2.head()\n\n\n\n\n\n\n\n\n\nName\nGender\nYearOfBirth\nAge\n\n\n\n\n0\nAlice\nf\n1999\n25\n\n\n1\nBob\nm\n1985\n39\n\n\n2\nMallory\nf\n1997\n27\n\n\n3\nMallory\nf\n1990\n34\n\n\n4\nBob\nm\n1987\n37\n\n\n\n\n\n\n\n\n\ndf2_by_gender = df2.groupby(\"Gender\")\ndf2_by_gender\n\n&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x7fa6920a7f10&gt;\n\n\n\ndf2_by_gender[\"Age\"].mean()\n\nGender\nf    30.0\nm    38.0\nName: Age, dtype: float64",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pandas</span>"
    ]
  },
  {
    "objectID": "01-Python/01-05-Pandas-Ex.html",
    "href": "01-Python/01-05-Pandas-Ex.html",
    "title": "5  Übung zu Pandas",
    "section": "",
    "text": "Für den Zweck der Buchhaltung in einem Unternehmen soll ein DataFrame erstellt werden, welches die folgenden Spalten enthält:\n\nPosition: Die Position im Unternehmen\nArbeitszeit: Die Arbeitszeit pro Woche\nLohn: Der wöchentliche Lohn in Euro\n\nDie Werte für die Position sollen aus der folgenden Liste entnommen werden:\nPosition: ['CEO', 'CFO', 'CTO', 'CIO', 'COO', 'CDO', 'CMO', 'CRO', 'CSO', 'CPO']\nArbeitszeit: [40, 40, 20, 40, 20, 40, 10, 40, 40, 60]\nGehalt: [10000, 8500, 2000, 3022, 1039, 2500, 3000, 1800, 20000, 10000]\n\n6 Aufgabe 1\n\nNennen Sie den DataFrame df und geben Sie ihn aus.\nGeben Sie die Spalte Position aus.\nGeben Sie die ersten 3 Zeilen des DataFrames aus.\nGeben Sie die letzten 3 Zeilen des DataFrames aus.\nGeben Sie die ersten 3 Zeilen der Spalte Position aus.\nGeben Sie die letzten 3 Zeilen der Spalte Position aus.\nGeben Sie die ersten 3 Zeilen der Spalten Position und Gehalt aus.\n\n\n\n7 Aufgabe 2\n\nBerechnen Sie den durchschnittlichen Gehalt im Unternehmen.\nBerechnen Sie den Stundenlohn für jede Personen im Unternehmen.\nBerechnen Sie den durchschnittlichen Stundenlohn im Unternehmen.\nBerechnen Sie den durchschnittlichen Stundenlohn für jede Position im Unternehmen.\nFinden Sie den niedrigsten Stundenlohn im Unternehmen.\nFinden Sie die Position mit dem niedrigsten Stundenlohn im Unternehmen.\nFinden Sie den höchsten Stundenlohn im Unternehmen.",
    "crumbs": [
      "Einführung in Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Übung zu Pandas</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/01-Berlin-Airlift.html",
    "href": "03-Graphical-Method/01-Berlin-Airlift.html",
    "title": "6  Die Berliner Luftbrücke",
    "section": "",
    "text": "6.1 Problembeschreibung\nDer Einfachheit halber nehmen wir an, dass die Lieferungen nach Berlin mit zwei Arten von Flugzeugen erfolgen: amerikanischen, die bis zu 30.000 Kubikfuß Fracht (\\approx 849 m^3) aufnehmen können, und britischen Flugzeugen mit einer Kapazität von bis zu 20.000 Kubikfuß (\\approx 566 m^3).\nWie viele Flugzeuge jeder Art sollten eingesetzt werden, um das Frachtvolumen zu maximieren?",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Die Berliner Luftbrücke</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/01-Berlin-Airlift.html#problembeschreibung",
    "href": "03-Graphical-Method/01-Berlin-Airlift.html#problembeschreibung",
    "title": "6  Die Berliner Luftbrücke",
    "section": "",
    "text": "Aufgrund von Einschränkungen in der Infrastruktur können an einem Tag maximal 48 Flugzeuge (unabhängig von der Art) fliegen.\nFür jeden Flug eines amerikanischen Flugzeugs sind 16 Personen erforderlich, doppelt so viele wie für britische Flugzeuge. Insgesamt stehen 512 Personen pro Tag zur Verfügung.\nDie Kosten für Treibstoff und Wartung der Flugzeuge betragen 9000 Dollar pro Flug für amerikanische Flugzeuge und 5000 Dollar pro Flug für britische Flugzeuge. Aufgrund von Budgetbeschränkungen dürfen die Gesamtkosten 300.000 Dollar nicht überschreiten.",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Die Berliner Luftbrücke</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/01-Berlin-Airlift.html#das-mathematische-modell",
    "href": "03-Graphical-Method/01-Berlin-Airlift.html#das-mathematische-modell",
    "title": "6  Die Berliner Luftbrücke",
    "section": "6.2 Das mathematische Modell",
    "text": "6.2 Das mathematische Modell\n\n\n\n\n\n\nZielvariablen\n\n\n\n\n\n\n\\begin{align*}\n& x_A: \\text{ Anzahl amerikanischer Luftzeuge}\\\\\n& x_B: \\text{ Anzahl britischer Luftzeuge}\n\\end{align*}\n\n\n\n\n\n\n\n\n\n\nZielfunktion\n\n\n\n\n\nDas Frachtvolumen ist die Summe der Frachtvolumina der beiden Flugzeugtypen:\n\nz(x_A, x_B) = 3 x_A + 2 x_B\n\n\n\n\n\n\n\n\n\n\nEinschränkungen\n\n\n\n\n\n\n\\begin{align*}\n& x_A + x_B \\leq 48 & \\text{ (Infrastruktur)} \\\\\n& 16 x_A + 8 x_B \\leq 512 & \\text{ (Personal)} \\\\\n& 9 x_A + 5 x_B \\leq 300 & \\text{ (Kosten)} \\\\\n& x_A  \\geq 0 &  \\\\\n& x_B \\geq 0 &\n\\end{align*}\n\n\n\n\n\n\n\n\n\n\nDas ganze Modell\n\n\n\n\n\n\n\\begin{align*}\n& \\max z(x_A, x_B) = 3 x_A + 2 x_B \\\\\n& \\text{under den Bedingungen:} \\\\\n& x_A + x_B \\leq 48 \\\\\n& 16 x_A + 8 x_B \\leq 512 \\\\\n& 9 x_A + 5 x_B \\leq 300 \\\\\n& x_A  \\geq 0 \\\\\n& x_B \\geq 0\n\\end{align*}\n\n\n\n\nBevor wir die Lösung des Problems diskutieren, lassen Sie uns die Aufgabe nur unter der ersten Beschränkung (Infrastruktur) betrachten.\n\n\\begin{align*}\n\\max 3 x_A + 2 x_B \\\\\nx_A + x_B \\leq 48 \\\\\nx_A \\geq 0 \\\\\nx_B \\geq 0\n\\end{align*}\n\nLösung:\n\n(x_A^* = 48, x_B^* = 0)",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Die Berliner Luftbrücke</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/01-Berlin-Airlift.html#die-zulässige-menge-feasible-set",
    "href": "03-Graphical-Method/01-Berlin-Airlift.html#die-zulässige-menge-feasible-set",
    "title": "6  Die Berliner Luftbrücke",
    "section": "6.3 Die zulässige Menge (Feasible Set)",
    "text": "6.3 Die zulässige Menge (Feasible Set)\nZuerst werden wir die zulässige Menge graphisch darstellen, indem wir die Geraden zu jeder der fünf Beschränkungen (einschließlich der Nichtnegativitätsbeschränkungen) zeichnen. Um die Geraden zeichnen zu können, benötigen wir jeweils zwei Punkte. Die einfachste Möglichkeit, die Schnittpunkte mit den beiden Achsen (x_A und x_B) zu finden.\nDie Gerade zur ersten Beschränkung (Infrastruktur) ist:\n\nx_A + x_B = 48\n\nSchnittpunkte mit den beiden Achsen:\n\nFür x_A = 0 ist x_B = 48\nFür x_B = 0 ist x_A + 0 = 48\n\nDie Gerade zur zweiten Beschränkung (Personal) ist:\n\n16 x_A + 8 x_B = 512\n\nDie Schnittpunkte mit den beiden Achsen:\n\nFür x_A = 0: 16 \\cdot 0 + 8x_B = 512 \\implies x_B = 512 / 8 = 64\nFür x_B = 0: 16 x_A +8 \\cdot 0 = 512 \\implies x_A = 512 / 16 = 32\n\nAuf die gleiche Weise können wir die Schnittpunkte für die dritte Beschränkung (Kosten) finden: (0, 300 / 5) и (300 / 9, 0).\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n\nax.plot([0, 48], [48, 0], label=r'$x_A + x_B = 48 \\quad Infrastruktur$')\nax.plot([0, 32], [64, 0], label=r'$16 x_A + 8 x_B = 512\\quad Personal$')\nax.plot([0, 33.33], [60, 0], label=r'$9 x_A + 5 x_B = 300 \\quad Kosten$')\n\nax.legend(loc=0)\n\n\n\n\n\n\n\n\n\nimport polytope as pc\nimport numpy as np\n\nA = np.array([[1, 1], [16, 8], [9, 5], [-1, 0], [0, -1]])\nb = np.array([48, 512, 300, 0, 0])\n\nP = pc.Polytope(A, b)\nextreme_points = pc.extreme(P)\n\nextreme_points\n\n`polytope` failed to import `cvxopt.glpk`.\nwill use `scipy.optimize.linprog`\n\n\narray([[32., -0.],\n       [20., 24.],\n       [15., 33.],\n       [-0., 48.],\n       [-0., -0.]])\n\n\nDie zulässige Menge ist durch die Eckpunkte (0, 0), (32, 0), (20, 24), (15, 33), (0, 48) beschrieben.\n\nfrom matplotlib import pyplot as plt\n\nplt.plot(extreme_points[:, 0], extreme_points[:, 1], '-o')\n\nfor i, p in enumerate(extreme_points):\n    plt.text(p[0], p[1], f\"({p[0]:0.1f}, {p[1]:0.1f})\")\n\n\n\n\n\n\n\n\n\ndef z(x_A, x_B):\n    return 3 * x_A + 2 * x_B\n\n# (0, 0)\nprint(\"z(0, 0) = \", z(0, 0))\n\n# (32, 0)\nprint(\"z(32, 0) = \", z(32, 0))\n\n# (20, 24)\nprint(\"z(20, 24) = \", z(20, 24))\n\n# (15, 33)\nprint(\"z(15, 33) = \", z(15, 33))\n\n# (0, 48)\nprint(\"z(0, 48) = \", z(0, 48))\n\nz(0, 0) =  0\nz(32, 0) =  96\nz(20, 24) =  108\nz(15, 33) =  111\nz(0, 48) =  96\n\n\nDie optimale Kombination von amerikanischen und britischen Flugzeugen ist (x_A^* = 15, x_B^* = 33). Dies ist die größtmögliche Ladung, die die Flugzeuge unter den gegebenen Beschränkungen transportieren können. Diese Ladung beträgt 30000 \\cdot 15 + 20000 \\cdot 33 = 1 110 000 Kubikfuß, die mit 15 amerikanischen und 33 britischen Flugzeugen transportiert werden.",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Die Berliner Luftbrücke</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/01-Berlin-Airlift.html#das-problem-mit-diesem-ansatz",
    "href": "03-Graphical-Method/01-Berlin-Airlift.html#das-problem-mit-diesem-ansatz",
    "title": "6  Die Berliner Luftbrücke",
    "section": "6.4 Das Problem mit diesem Ansatz",
    "text": "6.4 Das Problem mit diesem Ansatz\nNun haben wir die Optimierungsaufgabe gelöst, indem wir die Eckpunkte der zulässigen Menge berechnet und die Zielfunktion in jedem von ihnen berechnet haben. Die Lösung der Maximierungsproblems war der Punkt mit dem höchsten Wert der Zielfunktion.\nLeider ist dieser Ansatz für praktische Zwecke unbrauchbar, denn die Anzahl der Eckpunkte der zulässigen Menge wächst mit der Anzahl der Beschränkungen und Variablen. Eine obere Schranke für die Anzahl der Eckpunkte der zulässigen Menge ist durch den binomischen Koeffizienten gegeben:\n\n\\binom{n}{k} = \\frac{n!}{k!(n-k)!}\n\ndabei ist n die Anzahl der Variablen und k die Anzahl der Beschränkungen. Wir können die obere Schranke für die Anzahl der Eckpunkte der zulässigen Menge für verschiedene Kombinationen von n und k berechnen:\n\nfrom scipy.special import comb\n\nprint(\"n = 20, k = 15, Maximale Anzahl von Eckpunkten = \", comb(20, 15))\nprint(\"n = 40, k = 25, Maximale Anzahl von Eckpunkten = \", comb(40, 25))\nprint(\"n = 50, k = 25, Maximale Anzahl von Eckpunkten = \", comb(50, 25))\n\nn = 20, k = 15, Maximale Anzahl von Eckpunkten =  15504.0\nn = 40, k = 25, Maximale Anzahl von Eckpunkten =  40225345056.0\nn = 50, k = 25, Maximale Anzahl von Eckpunkten =  126410606437752.05\n\n\nSelbst mit einem relativ kleinen Problem, das 80 Variablen und 40 Beschränkungen hat, ist die Anzahl der Eckpunkte der zulässigen Menge astronomisch. Nehmen wir an, daß ein Rechnerkern 1 Milliarde Eckpunkte pro Sekunde berechnen kann. Dann würde es ungefähr 1.8 Millionen Jahre dauern, um alle Operationen durchzuführen.\n\ncomb_n = comb(80, 45)\nprint(round(comb_n / (1e9 * 60 * 60 * 24 * 365), 1), \"Jahre\")\n\n1836016.6 Jahre",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Die Berliner Luftbrücke</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/01-Berlin-Airlift.html#lösung-mit-excel",
    "href": "03-Graphical-Method/01-Berlin-Airlift.html#lösung-mit-excel",
    "title": "6  Die Berliner Luftbrücke",
    "section": "6.5 Lösung mit Excel",
    "text": "6.5 Lösung mit Excel\nHier herunterladen",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Die Berliner Luftbrücke</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/01-Berlin-Airlift.html#lösung-mit-gurobi-und-python",
    "href": "03-Graphical-Method/01-Berlin-Airlift.html#lösung-mit-gurobi-und-python",
    "title": "6  Die Berliner Luftbrücke",
    "section": "6.6 Lösung mit gurobi und Python",
    "text": "6.6 Lösung mit gurobi und Python\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport pandas as pd\n\n# New model instance\n\nm = gp.Model(\"Berlin Airlift\")\n\nx_A = m.addVar(vtype=GRB.CONTINUOUS, lb = 0, name=\"American\")\nx_B = m.addVar(vtype=GRB.CONTINUOUS, lb = 0, name=\"British\")\n\n# Objective function\n\nm.setObjective(3 * x_A + 2 * x_B, GRB.MAXIMIZE)\n\n# Constraints\n\nm.addConstr(x_A + x_B &lt;= 48, \"Infrastructure\")\nm.addConstr(16 * x_A + 8 * x_B &lt;= 512, \"Staff\")\nm.addConstr(9 * x_A + 5 * x_B &lt;= 300, \"Budget\")\n\n# Non-negativity constraints are added automatically in addVar\n\n# Solving the model\nm.optimize()\n\n# Print the solution\nfor v in m.getVars():\n    print(f\"{v.varName}: {v.x}\")\n\nRestricted license - for non-production use only - expires 2025-11-24\nGurobi Optimizer version 11.0.0 build v11.0.0rc2 (linux64 - \"Ubuntu 22.04.4 LTS\")\n\nCPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]\nThread count: 2 physical cores, 4 logical processors, using up to 4 threads\n\nOptimize a model with 3 rows, 2 columns and 6 nonzeros\nModel fingerprint: 0xbbf91f0b\nCoefficient statistics:\n  Matrix range     [1e+00, 2e+01]\n  Objective range  [2e+00, 3e+00]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [5e+01, 5e+02]\nPresolve time: 0.00s\nPresolved: 3 rows, 2 columns, 6 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    1.7500000e+30   4.687500e+30   1.750000e+00      0s\n       3    1.1100000e+02   0.000000e+00   0.000000e+00      0s\n\nSolved in 3 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  1.110000000e+02\nAmerican: 14.999999999999993\nBritish: 33.000000000000014\n\n\n\ntmp = {v.varName: [v.x] for v in m.getVars()}\nres_df = pd.DataFrame(tmp)\nres_df.head()\n\n\n\n\n\n\n\n\n\nAmerican\nBritish\n\n\n\n\n0\n15.0\n33.0",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Die Berliner Luftbrücke</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/02-Blending.html",
    "href": "03-Graphical-Method/02-Blending.html",
    "title": "7  Kaffeemischung",
    "section": "",
    "text": "7.1 Zulässige Menge\nDer erste Schritt ist die (grafische) Bestimmung der zulässigen Menge. Dazu zeichnen wir die Geraden zu den Ungleichungen bilden.\n\\begin{align}\n0.5 x_1 + 0.25 x_2  & = 120 \\\\\n0.5 x_1 + 0.75 x_2  & = 160 \\\\\n0 \\cdot x_1 + x_2   & = 150 \\\\\nx_1  & = 0 \\\\\nx_2  & = 0\n\\end{align}\n\\tag{7.1}\nWir zeichnen all die Geraden, die zu den Gleichungen gehören. Wenn man das per Hand macht, ist es am leichtesten die Schnittpunkte jeder Gerade mit den Koordinatenachsen zu bestimmen.\nDie Geraden sind in Abbildung 7.1 dargestellt.\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom IPython.display import display\n\nfig, ax = plt.subplots()\n\nax.plot([0, 240], [480, 0], label=r\"$0.5 x_1 + 0.25 x_2 = 120$ (Arabica)\")\nax.plot([0, 320], [213.33, 0], label=r\"$0.5 x_1 + 0.75 x_2 = 160$ (Robusta)\")\nax.plot([0, 400], [150, 150], label=r\"$x_2 = 150$ (Nachfrage Deluxe)\")\n\nax.set_xlim((0, 400))\nax.set_ylim((0, 500))\nax.set_xlabel(r'$x_1$ (Super, kg)')\nax.set_ylabel(r'$x_2$ (Deluxe, kg)')\nax.legend(loc=0)\n\n\n\n\n\n\n\n\nAbbildung 7.1: Die Geraden der drei Restriktionen des Kaffeeproblems\nDie zulässige Menge ist durch die Schnittpunkte der Geraden definiert. In Abbildung 7.1 ist das Polygon definiert durch\nUm die Koordinaten des Schnittpunkts der Geraden zu “Super” und “Deluxe” zu finden, müssen wir das System der beiden Gleichungen lösen\n\\begin{align}\n0.5 x_1 + 0.25 x_2 & = 120 \\text{ (1: арабика)} \\\\\n0.5 x_1 + 0.75 x_2 & = 160 \\text{ (2: робуста)}\n\\end{align}\nZum Beispiel können wir die erste Gleichung von der zweiten subtrahieren, um x_1 zu eliminieren:\n\\begin{align}\n(0.75 - 0.25) x_2 & = 160 - 120 \\\\\n0.5 x_2 & = 40 \\\\\nx_2 & = 80\n\\end{align}\nEinsetzen mit x_2 = 80 in die erste Gleichung ergibt\n\\begin{align}\n0.5 x_1 + 0.25 \\cdot 80 & = 120\\\\\nx_1 & = 200.\n\\end{align}\nAm Ende erhalten wir (200, 80) als Lösung des Gleichungssystems und daher die Koordinaten des Schnittpunkts der Geraden zu “Super” und “Deluxe”.\nUm den Schnittpunkt der Geraden zu “Robusta” und “Nachfrage Deluxe” zu finden, müssen wir das System der beiden Gleichungen lösen\n\\begin{align}\n0.5x_1 + 0.75 x_2 & = & 160 \\text{ робуста}\\\\\n0 x_1 + x_2 & = & 150 \\text{ търсене на Делукс}\n\\end{align}\nAls Lösung erhalten wir (95, 150).\nAuf diese Art und weise haben wir alle Eckpunkte der zulässigen Menge bestimmt: (0, 0), (240, 0), (200, 80), (95, 150), (0, 150) (Abbildung 7.2).\nCode\nvertices = [\n    [0, 0],\n    [0, 150],\n    [95, 150],\n    [200, 80],    \n    [240, 0]\n]\n\nvertices_x = [v[0] for v in vertices]\nvertices_y = [v[1] for v in vertices]\n\nfor v in vertices:\n    ax.annotate(\n        f\"({v[0]}, {v[1]})\",\n        (v[0], v[1]),\n        textcoords=\"offset points\",\n        xytext=(0, 5)\n    )\n\nax.fill(vertices_x, vertices_y, color='grey', alpha=0.3)\n\ndisplay(fig)\n\n\n\n\n\n\n\n\nAbbildung 7.2: Zulässige Menge für die Kaffeeproduktion",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Kaffeemischung</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/02-Blending.html#zulässige-menge",
    "href": "03-Graphical-Method/02-Blending.html#zulässige-menge",
    "title": "7  Kaffeemischung",
    "section": "",
    "text": "0.5 x_1 + 0.25 x_2 = 120. Die Gerade schneidet die x_1-Achse bei x_1 = 120 / 0.5 = 240 und die x_2-Achse bei x_2 = 120 / 0.25 = 480.\n0.5 x_1 + 0.75 x_2 = 160. Die Gerade schneidet die x_1-Achse bei x_1 = 160 / 0.5 = 320 und die x_2-Achse bei x_2 = 160 / 0.75 = 213.33.\nx_2 = 150. Die Gerade schneidet die x_2-Achse bei x_2 = 150 und ist parallel zur x_1-Achse.\nx_1 = 0. Diese Gerade stimmt mit der x_2-Achse überein.\nx_2 = 0. Diese Gerade stimmt mit der x_1-Achse überein.\n\n\n\n\n\nDer Schnittpunkt der beiden Nichtnegativitätsbedingungen: (0, 0)\nDer Schnittpunkt der Nichtnegativitätsbedingung von Super (der x_1-Achse) und Arabica: (240, 0).\nDer Schnittpunkt der Geraden zu Arabica und Robusta: (200, 80).\nDer Schnittpunkt der Geraden zu Robusta und Nachfrage Deluxe: (95, 150).\nDer Schnittpunkt der Geraden zu Nachfrage Deluxe und der Nichtnegativitätsbedingung von Deluxe (der x_1-Achse): (0, 150).",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Kaffeemischung</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/02-Blending.html#die-zielfunktion",
    "href": "03-Graphical-Method/02-Blending.html#die-zielfunktion",
    "title": "7  Kaffeemischung",
    "section": "7.2 Die Zielfunktion",
    "text": "7.2 Die Zielfunktion\nUm den optimalen Plan zu bestimmen, werden wir die Zielfunktion in die Grafik einzeichnen. Die Zielfunktion z(x_1, x_2) = 40 x_1 + 50 x_2 ist in Abbildung 7.3 dargestellt. Die Zielfunktion ist eine Ebene im dreidimensionalen Raum.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom mpl_toolkits.mplot3d.art3d import Poly3DCollection\n\n# Create the x, y, and z coordinate arrays\nx, y = np.meshgrid(np.linspace(0, 250, 20), np.linspace(0, 250, 20))\nz = 40 * x + 30 * y\n\n# Create a figure\nfig = plt.figure()\n\nax = fig.add_subplot(111, projection='3d')\n\n# Add a 3D subplot\nax.plot_surface(x, y, z, rstride=5, cstride=5, edgecolor='k', alpha=0.5)\nax.view_init(elev=25, azim=-120)\nax.set_xlabel(r\"$x_1$ (Super, kg)\")\nax.set_ylabel(r\"$x_2$ (Deluxe, kg)\")\nax.set_zlabel(r\"$z$ (Gewinn, kg)\")\n\nvertices_3d = [v + [0] for v in vertices]\n\n# Create a Poly3DCollection\npoly = Poly3DCollection([vertices_3d], alpha=.25, linewidths=1, edgecolors='r', facecolors='c')\n\n# Add the Poly3DCollection to the axes\nax.add_collection3d(poly)\n\n\n\n\n\n\n\n\nAbbildung 7.3: Die Zielfunktion des Kaffeeproblems\n\n\n\n\n\nDiese Visualisierung ist hilfreich, um zu verstehen, wie die Zielfunktion aussieht, aber sie hilft uns nicht, das Maximum innerhalb der zulässigen Menge zu finden. Daher werden wir die Projektion der Zielfunktion auf die Ebene der zulässigen Menge verwenden.\nFixieren wir ein paar (beliebige) Niveaus des Gewinns und zeichnen wir die Geraden, die sie repräsentieren. Nehmen wir an, dass diese Niveaus 5000, 10000 und 12000 sind. Um diese Geraden zu zeichnen, müssen wir die Schnittpunkte dieser Geraden mit den beiden Achsen finden.\nAlle Kombinationen von Super und Deluxe, die genau 5000 Gewinn erzielen, liegen auf einer Geraden, die durch die Gleichung\n\n40x_1 + 50x_2 = 5000\n\ngegeben sind.\nAlle Kombinationen von Super und Deluxe, die genau 10000 Gewinn erzielen, liegen auf einer Geraden, die durch die Gleichung\n\n40x_1 + 50x_2 = 10000\n\ngegeben sind.\nBeide Geraden verlaufen parallel zueinander, da der Anstieg der Geraden von den Koeffizienten von x_1 und x_2 in den Gleichungen abhängt und nicht von den Konstanten (5000 in der ersten Gleichung und 10000 in der zweiten).",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Kaffeemischung</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/02-Blending.html#der-normalvektor",
    "href": "03-Graphical-Method/02-Blending.html#der-normalvektor",
    "title": "7  Kaffeemischung",
    "section": "7.3 Der Normalvektor",
    "text": "7.3 Der Normalvektor\nAlle Geraden bei unterschiedlichem Gewinn haben denselben Normalvektor. Der Normalvektor ist der Vektor, der senkrecht einer Gerade steht. Der Normalvektor ist der Koeffizientenvektor der Variablen in der Zielfunktion. In unserem Fall ist der Normalvektor (40, 50).\nUm das zu begründen, betrachten wir die Gerade\n\n40x_1 + 50x_2 = 5000\n\nDiese Gerade schneidet die x_1-Achse bei x_1 = 5000 / 40 = 125 und die x_2-Achse bei x_2 = 5000 / 50 = 100. Aus diesen Zwei Punkten können wir die Parameterdarstellung der Geraden ableiten (für t \\in \\mathbb{R}).\nEine Gerade ist durch einen Punkt und eine Richtung definiert. Der Punkt ist der Schnittpunkt der Geraden mit der x_2-Achse, also (0, 100). Die Richtung ist der Vektor, der den Schnittpunkt der Geraden mit der x_1-Achse von dem Schnittpunkt der Geraden mit der x_2-Achse subtrahiert.\n\n\\begin{pmatrix}\nx_1 \\\\\nx_2\n\\end{pmatrix}\n= \\begin{pmatrix}\n0 \\\\\n100\n\\end{pmatrix}\n+ t \\left[\n\\begin{pmatrix}\n125 \\\\\n0\n\\end{pmatrix}\n-\n\\begin{pmatrix}\n0 \\\\\n100\n\\end{pmatrix}\n\\right]\n\nWir berechnen die Differenz und erhalten\n\n\\begin{pmatrix}\nx_1 \\\\\nx_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n100\n\\end{pmatrix}\n+ t\n\\begin{pmatrix}\n125 \\\\\n-100\n\\end{pmatrix}\n\nZwei Vektoren sind orthogonal, wenn ihr Skalarprodukt 0 ist. Das Skalarprodukt zweier Vektoren ist die Summe der Produkte ihrer entsprechenden Koordinaten. So erhalten wir\n\n\\begin{pmatrix}\n40 \\\\\n50\n\\end{pmatrix}\n\\cdot\n\\begin{pmatrix}\n125 \\\\\n-100\n\\end{pmatrix}\n= 40 \\cdot 125 + 50 \\cdot (-100) = 0\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nA = np.array([0, 100])\nB = np.array([125, 0])\nC = B - A\n\n# Create a figure\nfig, ax = plt.subplots()\n\n# Plot the vectors\nax.quiver(0, 0, A[0], A[1], angles='xy', scale_units='xy', scale=1, color='r', label='A')\nax.quiver(0, 0, B[0], B[1], angles='xy', scale_units='xy', scale=1, color='b', label='B')\nax.quiver(A[0], A[1], C[0], C[1], angles='xy', scale_units='xy', scale=1, color='g', label='B-A')\n\n# Set the limits of the plot\nax.set_xlim([-2, 125])\nax.set_ylim([-2, 125])\n\n# Add a legend\nax.legend(loc=0)\n\n\n\n\n\n\n\n\n\nLasst und die Geraden für 5000, 10000 und 12000 Gewinn zeichnen. Abbildung 7.4 zeigt die zulässige Menge und die Geraden für 3000, 50000 und 12000 Gewinn.\n\n\nCode\nfig, ax = plt.subplots()\n\nax.fill(vertices_x, vertices_y, color='grey', alpha=0.3)\nfor v in vertices:\n    ax.annotate(\n        f\"({v[0]}, {v[1]})\",\n        (v[0], v[1]),\n        textcoords=\"offset points\",\n        xytext=(0, 5)\n    )\n\nax.plot([0, 3000 / 40], [3000 / 50, 0], label=r'$40 x_1 + 50 x_2 = 3000$')\nax.plot([0, 5000 / 40], [5000 / 50, 0], label=r'$40 x_1 + 50 x_2 = 5000$')\nax.plot([0, 12000 / 40], [12000 / 50, 0], label=r'$40 x_1 + 50 x_2 = 12000$')\n\nax.quiver(0, 0, 40, 50, angles='xy', scale_units='xy', scale=1, color='grey', label='Der Normalvektor')\n\nax.set_xlim((0, 260))\nax.set_ylim((0, 260))\n\nax.legend(loc=0)\n\n\n\n\n\n\n\n\nAbbildung 7.4: Die graphische Lösung des Kaffeeproblems\n\n\n\n\n\nDie Gerade, die die zulässige Menge gerade noch berührt ist diejenige, die den maximalen Gewinn darstellt. Der Schnittpunkt der Geraden für 12000 Gewinn mit der zulässigen Menge ist der optimale Plan. In dieser Aufgabe ist das der Punkt (x^*_1 = 200, x^*_2 = 80) bei dem das Café 200 kg Super und 80 kg Deluxe kaufen sollte, um den maximalen Gewinn von 12000 € zu erzielen.\nIn dem optimalen Plan werden die ersten zwei Ressourcen vollständig ausgeschöpft, während die dritte Ressource nicht ausgeschöpft wird. Wie viel von der Nachfrage nach Deluxe bleibt unerfüllt?\n\n0.5 \\cdot 200 + 0.25 \\cdot 80 = 120 \\text{ kg Arabica}\n\nund\n\n0.5 \\cdot 200 + 0.75 \\cdot 80 = 160 \\text{ kg Robusta}.",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Kaffeemischung</span>"
    ]
  },
  {
    "objectID": "03-Graphical-Method/02-Blending.html#lösung-mit-gurobipy-1",
    "href": "03-Graphical-Method/02-Blending.html#lösung-mit-gurobipy-1",
    "title": "7  Kaffeemischung",
    "section": "7.4 Lösung mit gurobipy 1",
    "text": "7.4 Lösung mit gurobipy 1\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nm = gp.Model(\"Coffee Blending\")\n\n# Create variables\n\nsuper_espresso = m.addVar(name=\"super_espresso\")\ndeluxe_espresso = m.addVar(name=\"deluxe_espresso\")\n\n# Set objective\nm.setObjective(40 * super_espresso + 50 * deluxe_espresso, GRB.MAXIMIZE)\n\n# Add constraints\nm.addConstr(0.5 * super_espresso + 0.25 * deluxe_espresso &lt;= 120, \"Arabica\")\nm.addConstr(0.5 * super_espresso + 0.75 * deluxe_espresso &lt;= 160, \"Robusta\")\nm.addConstr(deluxe_espresso &lt;= 150, \"Nachfrage Deluxe\")\n\n# Optimize model\nm.optimize()\n\n# Print the solution\nfor v in m.getVars():\n    print(f\"{v.varName}, {v.x}\")\n\nRestricted license - for non-production use only - expires 2025-11-24\nGurobi Optimizer version 11.0.0 build v11.0.0rc2 (linux64 - \"Ubuntu 22.04.4 LTS\")\n\nCPU model: AMD EPYC 7763 64-Core Processor, instruction set [SSE2|AVX|AVX2]\nThread count: 2 physical cores, 4 logical processors, using up to 4 threads\n\nOptimize a model with 3 rows, 2 columns and 5 nonzeros\nModel fingerprint: 0xb45dd709\nCoefficient statistics:\n  Matrix range     [2e-01, 1e+00]\n  Objective range  [4e+01, 5e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [1e+02, 2e+02]\nPresolve removed 1 rows and 0 columns\nPresolve time: 0.00s\nPresolved: 2 rows, 2 columns, 4 nonzeros\n\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    2.4000000e+04   1.325000e+02   0.000000e+00      0s\n       2    1.2000000e+04   0.000000e+00   0.000000e+00      0s\n\nSolved in 2 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  1.200000000e+04\nsuper_espresso, 200.0\ndeluxe_espresso, 80.0",
    "crumbs": [
      "Die graphische Methode",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Kaffeemischung</span>"
    ]
  },
  {
    "objectID": "Homeworks.html",
    "href": "Homeworks.html",
    "title": "Hausaufgaben",
    "section": "",
    "text": "Um auf die Hausaufgaben zuzugreifen, klicken Sie auf den entsprechenden Link. Sie brauchen dazu ein GitHub-Konto.\n\nEinführung in Python: https://classroom.github.com/a/Fg2ngRdJ",
    "crumbs": [
      "Hausaufgaben"
    ]
  },
  {
    "objectID": "Links.html",
    "href": "Links.html",
    "title": "Resourcen",
    "section": "",
    "text": "https://www.gurobi.com/burrito-optimization-game/",
    "crumbs": [
      "Resourcen"
    ]
  },
  {
    "objectID": "Literature.html",
    "href": "Literature.html",
    "title": "Emfohlene Literatur",
    "section": "",
    "text": "Dietz und Dietz (2019) (Deutsch): Kapitel 23 und 24\nSchwenkert und Stry (2015) (Deutsch): Teil 1\nWilliams (2013) (English)\nTaha (2017) (English)\n\n\n\n\n\nDietz, Hans M., und Hans M. Dietz. 2019. Lineare Algebra und Optimierung. 3. Auflage. Mathematik für Wirtschaftswissenschaftler / Hans M. Dietz, Band 2. Berlin [Heidelberg]: Springer Spektrum. https://doi.org/10.1007/978-3-662-58702-7.\n\n\nSchwenkert, Rainer, und Yvonne Stry. 2015. Operations Research kompakt: Eine an Beispielen orientierte Einführung. 1. Aufl. 2015. Operations Research kompakt. Berlin: Gabler.\n\n\nTaha, Hamdy A. 2017. Operations Research. 10th ed. Harlow, United Kingdom: Pearson Education Limited.\n\n\nWilliams, Hilary P. 2013. Model Building in Mathematical Programming. Fifth Edition. Chichester: John Wiley & Sons Ltd.",
    "crumbs": [
      "Emfohlene Literatur"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literaturverzeichnis",
    "section": "",
    "text": "Dietz, Hans M., and Hans M. Dietz. 2019. Lineare Algebra und\nOptimierung. 3. Auflage. Mathematik für\nWirtschaftswissenschaftler / Hans M. Dietz, Band 2. Berlin\n[Heidelberg]: Springer Spektrum. https://doi.org/10.1007/978-3-662-58702-7.\n\n\nSchwenkert, Rainer, and Yvonne Stry. 2015. Operations Research\nkompakt: Eine an Beispielen orientierte Einführung. 1. Aufl.\n2015. Operations Research kompakt. Berlin:\nGabler.\n\n\nTaha, Hamdy A. 2017. Operations Research. 10th ed.\nHarlow, United Kingdom: Pearson Education\nLimited.\n\n\nWilliams, Hilary P. 2013. Model Building in Mathematical\nProgramming. Fifth Edition. Chichester: John\nWiley & Sons Ltd.",
    "crumbs": [
      "Literaturverzeichnis"
    ]
  }
]